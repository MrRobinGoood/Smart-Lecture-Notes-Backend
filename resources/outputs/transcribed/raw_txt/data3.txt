you you you you Добро пожаловать на третий урок курса введения в юнит тестирования. На этом уроке мы поговорим о качестве тестов. Но для начала давайте вспомним, о чем же мы говорили на предыдущей лекции. На предыдущей лекции мы дали определение юнит-тестам. Мы разобрались с тем, когда и где лучше их писать. Мы обсудили структуру тестов, рассмотрели существующие фреймворки для юнит-тестирования, познакомились с фреймворками семейства XUnit, а также установили и научились пользоваться фреймворком GUnit 5 для модульного тестирования. На данном уроке мы поговорим о качестве тестов, обсудим тестирование по принципу черного и белого ящиков, поговорим о метриках тестов, рассмотрим инструменты для измерения покрытия тестами, а также поговорим про разработку через тестирование и тестирование через поведение. Хорошие тесты помогают предотвратить стагнацию и сохранить темп разработки со временем. С хорошими тестами вы будете уверены в том, что изменения функциональности не приведут к новым ошибкам. Поэтому очень важно писать качественные тесты. И сегодня на уроке мы научимся писать качественные тесты, а также посмотрим на написание тестов несколько по другим углам, когда будем говорить о разработке через тестирование. Как мы помним из предыдущих лекций, целью юнит-тестирования является обеспечение стабильного роста проекта. Но невозможно добиться этой цели, просто написав большое количество тестов. Но невозможно добиться этой цели, просто написав большое количество тестов. Ведь они должны учитывать критичность функционала, который мы покрываем, а также стоимость их поддержки. Давайте представим себе две ситуации. Первая ситуация. Мы работаем на крупном проекте, хотим внести изменения в существующую функциональность и запускаем тесты. Наши тесты завершаются неудачей и мы тратим несколько дней на то, чтобы разобраться с причинами падений. В результате оказывается, что наш тест был написан некорректно и это было ложное срабатывание. Как минимум это неприятно. А также давайте рассмотрим еще одну ситуацию, когда мы запускаем наши тесты, они также завершаются неудачей и мы пытаемся разобраться, что же случилось. Приходим, смотрим, и нам совершенно непонятно, что же тестирует тест, потому что название метода непонятно, логи отсутствуют, структура теста нарушена. Все это забирает ресурсы у бизнеса, а нам, как разработчикам, доставляет дополнительные неудобства, дополнительные нервы и так далее. На данном слайде мы видим график с двумя линиями. Красная линия показывает нам проект без тестов, а зеленая линия проект с тестами. Как видим, проект без тестов стартует чуть раньше, но в дальнейшем он может стагнировать или вообще остановиться. Это происходит потому, что на начальном этапе мы не тратим никаких ресурсов на то, чтобы писать тесты, а переходим непосредственно к реализации бизнес-логики. Со временем, когда проект растет, количество бизнес-логики увеличивается, количество зависимости также увеличивается и становится все сложнее обнаруживать и исправлять дефекты. В то же время проект с тестами стартует несколько позже. Это происходит потому, что на начальном этапе мы тратим время на написание самих тестов и только потом переходим к реализации бизнес-логики. Но как видно по графику, проекты с тестами развиваются более стабильно, просто потому что тесты обеспечивают так называемую подушку безопасности когда мы добавляем новый функционал мы можем быть уверены в том что старый функционал не сломается ошибки поджидают нас на каждом этапе разработки ошибки могут возникать вследствие внесения изменений в существующую функциональность или при добавлении новой функциональности. Такие ошибки, как правило, называются регрессионными. Данное название происходит от слова «регресс», то есть это движение назад или откат. Во многих командах разработки выделяется отдельное время на регрессионное тестирование. Это некое собирательное определение всех возможных видов тестирования, которые проводятся для того, чтобы убедиться в том, что функционал, когда разработчики устраняют ранее обнаруженные дефекты и баги, а также когда мы исправляем проблемы с производительностью. Таким образом, мы можем говорить о том, что защита от регрессий – это первый атрибут качественного юнит-теста. Чем больше кода проверяет тест, тем выше вероятность выявить баг. Но недостаточно опираться только на такую метрику. Ведь если код не несет в себе никакой критической бизнес-логики, а выполняет достаточно тривиальные функции, то ценность такого теста падает. Поэтому при выборе функционала, который необходимо покрывать юнит тестами, необходимо четко осознавать, что мы тестируем и зачем. И как правило, выбор остается на стороне критичного бизнес-функционала. А теперь вопрос. Какие из представленных на слайде функций нужно тестировать, а какие нет? Первое. Метод, который возвращает сегодняшнее число. Этот метод может использоваться,аться например когда пользователь заходит на сайт и ему нужно подтвердить что его возраст 18 или более лет второе метод который проверяет доступен ли данный товар для самовывоза в интернет-магазине в конкретном городе то есть здесь мы говорим о ситу, когда пользователь зашел в интернет-магазин, выбирает город, выбирает понравившийся товар и хочет оформить доставку. Третий метод, который проверяет возможность авторизации пользователя. Точно так же можем спроецировать это на наш интернет-магазин. Допустим, что неавторизованные пользователи не могут осуществлять заказы. И четвертое это метод который ищет пользователя из базы данных по идее например если мы хотим позволить нашим пользователям интернет-магазина оставлять отзывы о товаре конечно мы можем протестировать вообще все но в основном это не имеет никакого смысла давайте же ответим на наш вопрос. Соответственно, метод, который возвращает сегодняшнее число, можно не тестировать. Это достаточно тривиальная операция и здесь можно обойтись только проверками if-else. А вот метод, который проверяет, доступен ли данный товар для самовывоза в интернет-магазине в конкретном городе, тестировать нужно, потому что это очень важный кусок бизнес логики для нашего интернет-магазина если он будет работать неправильно мы потеряем доход то же самое относится и к методу который проверяет возможность авторизации пользователя как мы и сказали ранее не авторизованные пользователи не могут осуществлять какие-либо заказы а значит если метод метод будет неправильным, мы также потеряем в деньгах. А вот метод, который ищет пользователя по идентификатору в базе данных, тестировать не обязательно. Хотя бы потому, что мы делаем запрос в базу через некую прослойку JPA, которая уже написана и протестирована до нас. Кроме того, такой запрос также является достаточно тривиальным. Резюмируя, первый атрибут качественного юнит-теста это защита от регрессии. Нужно тестировать как можно больше кода и при этом этот код должен нести какую-то важность с точки зрения бизнес-логики. Второй и третий атрибуты тесно связаны между собой. Когда мы пишем юнит-тест, мы должны задаваться вопросами, потребуются ли какие-либо изменения в нашем тесте в случае, если изменится реализация тестируемого функционала. И второй вопрос, как много ресурсов понадобится от тестировщика или разработчика, который впервые видит наш тест для того, чтобы внести изменения. Таким образом, мы приходим к тому, что второе и третье атрибуты – это устойчивость к новым изменениям и простота поддержки. То есть устойчивость к новым изменениям определяет, насколько хорошо тест может пережить рефакторинг тестируемого нами кода. Что такое рефакторинг? Рефакторинг это изменение деталей имплементации без изменения наблюдаемого поведения. А простота поддержки оценивает затраты на сопровождение кода. На слайде показано взаимодействие пользователя с тестируемой системой. Пользователь вводит какие-то данные, система производит необходимые вычисления, это шаг 1, шаг 2 и шаг 3 и возвращает пользователю какой-то результат. Давайте рассмотрим, как могла бы выглядеть такая схема взаимодействия на примере нашего класса калькулятор из прошлой лекции пользователь приходит передает метод операнды и оператор на первом шаге на втором шаге метод calculation производит необходимые вычисления а на третьем шаге метод возвращает пользователю результат на данном слайде мы видим пример плохого теста который неустойчив к изменениям когда мы пишем юнит тест очень неправильно привязываться к тому, как реализован метод, вместо того, чтобы проверять ожидаемый результат. Конечно, наш метод очень сложно протестировать неправильно, ведь там всего одна функция calculation. Рассмотрим еще один пример неудачного теста, привязанного к реализации метода. В данном тесте мы вычитываем содержимое класса калькулятор и пытаемся сравнить его с некой строкой, в которой мы описали ожидаемое содержимое нашего класса. Такой тест очень неустойчив к изменениям, потому что при малейших доработках в нашем классе он будет завершаться с ошибкой. На данном слайде мы видим пример правильно спроектированного теста. Хороший тест не должен основываться на внутренней реализации метода, а должен лишь проверять ожидаемый результат. Это как раз то, что интересно пользователю. И в случае, если в методе что-то произойдет не так мы получим неверный результат и это будет сигналом о том что образовался дефект тест должен проверять результаты работы они то как этот результат достигается конечно такой тест не идеален потому что в систему все еще можно внести изменения которые могут нарушить его работу. Например, можно добавить дополнительный шаг или изменить возвращаемый результат. На примере нашего метода Calculation можно представить, что в какой-то момент мы решили передавать параметры не отдельно, а вместе, одной строкой. Таким образом, это также будет ложное срабатывание, ведь мы не изменили логику вычислений. Но при этом стоит заметить, что такой тест все еще достаточно легко отрефакторить. Для этого необходимо всего лишь следовать рекомендациям нашей среды разработки. Теперь собираем все вместе. В данный момент мы обсудили уже три атрибута качественного юнит-теста. Первый – это защита от регрессий, второй – устойчивость к новым изменениям и третий – простота поддержки. Перейдем к четвертому атрибуту. Четвертый атрибут – это быстрая обратная связь. В идеальном случае тесты должны предупреждать нас об ошибках сразу же после внесения изменения в функциональность. В таком случае затраты на исправление дефектов сводятся практически до нуля. Если тесты будут выполняться медленно, их не будут поддерживать и это отобьет всяческую охоту у разработчика запускать их как можно чаще. Для того чтобы тесты выполнялись быстро, они должны быть первое небольшими и второе должны быть изолированы от каких-то других зависимостей. Итак, четыре атрибута хороших юнит тестов. Первое – защита от регрессий. Второе – устойчивость к новым изменениям. Третье – простота поддержки. И четвертое – быстрая обратная связь. Все эти атрибуты применимы не только к юнит тестом могут применяться также и к другим видам тестов например к интеграционным к сожалению не существует какой-то утилиты в которую можно было бы просто передать тест и она выдала бы нам оценку качества нашего теста но при этом чисто логически можно оценить качество наших тестов по каждому из этих атрибутов чтобы тест был эффективным он должен демонстрировать результативность в каждой из четырех категорий но к сожалению все эти категории взаимоисключающие поэтому такой тест создать невозможно четвертый атрибут простота поддержки не сильно связан с остальными тремя, за исключением сквозных end-to-end тестов. Поэтому будем рассматривать его совместно с атрибутом «устойчивость к новым изменениям». Таким образом, невозможно довести все три атрибута до максимума, каким-то одним придется пожертвовать. Поэтому нужно решать для себя в контексте каждого проекта, какие атрибуты являются более приоритетными. Рассмотрим пример сквозные или end-to-end тесты. Как мы помним из прошлых лекций, это не все.